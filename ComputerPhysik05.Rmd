---
title: 'Übung 05: Spektrum einer Klaviersaite'
author: "Tobias Blesgen und Leonardo Thome"
date: "27.06.2021"
output:
  pdf_document: default
  html_document:
    df_print: paged
header-includes: 
 - \usepackage{amssymb}
 - \usepackage{amsmath}
 - \usepackage[ngerman]{babel}
 - \bibliographystyle{unsrtnat}
---

[//]: # Ausführbefehl im allgemeinen: ``render("ComputerPhysik05.Rmd")``

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Schlägt man eine Klaviersaite an, so verhält sie sich nach:

\begin{equation} \label{gl1}
      \frac{\partial^2\psi(x,t)}{\partial t^2} = c^2 \frac{\partial^2\psi(x,t)}{\partial x^2} - \frac{\gamma}{l}|\frac{\partial \psi (x,t)}{\partial t}|(\frac{\partial \psi (x,t)}{\partial t}).
\end{equation}

Wir wollen dieses Verhalten im Folgenden numerisch untersuchen. Hierzu schreiben wir Gleichung \ref{gl1} mit $\Xi = \frac{x}{l}, \phi = \frac{\psi}{l}, \tau = \frac{tc}{l}$ um zu einer Dimensionslosen Gleichung:

\begin{equation}\label{gl2}
      \frac{\partial^2\phi(\Xi,\tau)}{\partial \tau^2} = \frac{\partial^2\phi(\Xi,\tau)}{\partial \Xi^2} - \gamma|\frac{\partial \phi(\Xi,\tau)}{\partial \tau}|(\frac{\phi(\Xi,\tau)}{\partial \tau}).
\end{equation}

Um dieses Problem analytisch angehen zu können, müssen wir die Differentiale annähern und schreiben hierzu die Gleichung \ref{gl2} um zu:

\begin{equation}
  \frac{\psi_{i+1, j} - 2\psi_{i,j} + \psi_{i-1,j}}{\Delta \tau^2} =  \frac{\psi_{i,j+1} - 2\psi_{i,j} + \psi_{i,j-1}}{\Delta \Xi^2} - \gamma |\frac{\psi_{i,j}-\psi_{i-1,j}}{\Delta \tau}| \frac{\psi_{i,j}-\psi_{i-1,j}}{\Delta \tau}
\end{equation}

Dies lässt sich weiter umstellen zu:

\begin{equation}
  \psi_{i+1,j} = \frac{\Delta \tau^2}{\Delta \Xi^2} (\psi_{i,j+1} - 2\psi_{i,j} + \psi_{i,j-1}) + 2\psi_{i,j} - \psi_{i-1,j} - \gamma |\psi_{i,j}-\psi_{i-1,j}|(\psi_{i,j}-\psi_{i-1,j})
\end{equation}

Diese Gleichung wird nun verwendet um iterativ den nächsten Funktionswert an jedem Ort zu bestimmen. Als Randbedingung werden die Ränder, also $\Xi = 0$ und $\Xi = \Xi_{max}$ auf 0 gesetzt, da sie im Klavier befestigt sind.

# Implementation des numerischen Verfahrens

Nach der Courant-Friedrichs-Lewy Stabilitätsbedingung müssen wir bei der Schrittweite Wahl beachten das stets

\begin{equation}
  1 \geq c\frac{\Delta t}{ \Delta x}
\end{equation}

gilt. Setzen wir $\Xi$ und $\tau$ ein, so erhalten wir nach einmaligen Umstellen die Ungleichung

\begin{equation}
  \Delta \Xi \geq \frac{cl}{cl}\Delta \tau = \Delta \tau.
\end{equation}

Wir müssen also darauf achten die $\tau$-Schritte kleiner als die $\Xi$-Schritte zu halten.

```{Rcpp}
#include<Rcpp.h>
#include<vector>
#include<algorithm>
#include<math.h>  

using namespace Rcpp;


//[[Rcpp::export]]
NumericMatrix klaviersaite2(const double gamma, const int xSchritte,
                                              const double dt, const int 
                                              zeitSchritte){
  // Array der Werte zur späteren Ausgabe
    NumericMatrix matrix(zeitSchritte, xSchritte);
  // Quelltext
    // Startwerte
    
    for (int i = 0; i<xSchritte; i++){
      matrix(0,i) = 0.0;
      matrix(1,i) = 0.0;
    }
    matrix(0,(int)(0.26*(xSchritte-1))) = 0.01/0.4;
    matrix(1,(int)(0.26*(xSchritte-1))) = 0.01/0.4;
    

    
    // Funktionsdurchläufe
    double dx = 1.0/(xSchritte - 1.0);
    double C = dt*dt/(dx*dx);
    
    for (int i = 2; i<zeitSchritte; i++){
      // Randbedingungen
      matrix(i,0) = 0.0;
      matrix(i,xSchritte-1) = 0.0;
      for (int j = 1; j<xSchritte-1; j++){
        matrix(i,j) = C*(matrix(i-1,j+1) - 2*matrix(i-1,j) + 
          matrix(i-1,j-1)) + 2*matrix(i-1,j) - matrix(i-2,j) - 
          gamma * fabs(matrix(i-1,j)-matrix(i-2,j)) *
          (matrix(i-1,j)-matrix(i-2,j));
      }
    }
    
  // Rückgabe für eine grafische Wiedergabe
    return matrix;
}

```

```{r, echo=FALSE, fig.cap="\\label{fig:Zeitentwicklung} Zeitliche Entwicklung", fig.width=7,fig.height=4}
library(latex2exp)
xSchritte = 500
dt = 0.001
zeitSchritte = 500
gamma = 1/3
datenMatrix = klaviersaite2(gamma, xSchritte, dt, zeitSchritte)
plot((0:299)/500, datenMatrix[1,c(1:300)],"l" ,xlab = TeX(r'($\Xi$)'), ylab = TeX(r'($\psi$)'))
for (x in 1:5){
  lines((0:299)/500, datenMatrix[10*x^2,c(1:300)],"l", col = rainbow(10)[x])
}

```

```{r, echo=FALSE, fig.cap="\\label{fig:Zeitentwicklung2} zweite Zeitliche Entwicklung", fig.width=7,fig.height=4}
library(latex2exp)
xSchritte = 990
dt = 0.001
zeitSchritte = 1000
gamma = 1/3
datenMatrix = klaviersaite2(gamma, xSchritte, dt, zeitSchritte)
plot((0:599)/xSchritte, datenMatrix[1,c(1:600)],"l" ,xlab = TeX(r'($\Xi$)'), ylab = TeX(r'($\psi$)'))
for (x in 1:5){
  lines((0:599)/xSchritte, datenMatrix[40*x^2,c(1:600)],"l", col = rainbow(10)[x])
}

```

```{r, echo=FALSE, fig.cap="\\label{fig:Zeitentwicklung2} zweite Zeitliche Entwicklung", fig.width=7,fig.height=4}
library(latex2exp)
xSchritte = 500
dt = 0.001
zeitSchritte = 1000
gamma = 1/3
datenMatrix2 = klaviersaite2(gamma, xSchritte, dt, zeitSchritte)
plot((1:1000)*0.0001, datenMatrix2[c(1:1000),0.3*xSchritte],"l" ,xlab = TeX(r'($\tau$)'), ylab = TeX(r'($\psi$)'))
```
```{r, echo=FALSE, fig.cap="\\label{fig:Zeitentwicklung2} zweite Zeitliche Entwicklung", fig.width=7,fig.height=4}
library(latex2exp)
xSchritte = 500
dt = 0.0001
zeitSchritte = 10000
gamma = 1/3
datenMatrix3 = klaviersaite2(gamma, xSchritte, dt, zeitSchritte)
plot((1:10000)*0.0001, datenMatrix3[c(1:10000),0.3*xSchritte],"l" ,xlab = TeX(r'($\tau$)'), ylab = TeX(r'($\psi$)'))
```


## FFT

```{Rcpp}
#include <Rcpp.h>
#include <stdlib.h>

using namespace Rcpp;

double pi = 3.14159;
std::complex<double> I = 1i;

// Generiere die w Faktoren
std::vector<std::complex<double>> wInit(int n){
  std::vector<std::complex<double>> W(n);
  for (int a = 0; a < n; a++)
    {
        W[a]= exp(-2.*pi*I*(double)a)/((double)n);
    }
  return W;
}

// Funktion zum Umsortieren der verdrehten Terme
void fftResort(const int n, int* k){
    int l = 0, m;
    for (int i = 0; i <= n-2; i++)
    {
        k[i] = l;
        m = n/2;
        while (m <= l)
        {
            l -= m;
            m /= 2;
        }
        l += m;
    }
    k[n-1] = n-1;
}

// Fast Fourier Transform - Funktion (nimmt die z_i und gibt die g_i unsortiert aus)
std::vector<std::complex<double>> fft (std::vector<std::complex<double>> z, const int r){
    const int n = pow(2,r);
    int m = n/2;
    int K = 1;
    std::vector<std::complex<double>> w = wInit(n);
    int a, b;
    
    for (int i = 0; i < r; i++)
    {
        for (int k = 0; k < K; k++)
        {
            for (int j = 0; j < m; j++)
            {
                a = 2*k*m +j;
                b = a + m;
                z[a] += z[b];
                z[b] = w[K*j]*(z[a] - 2.0*z[b]);
            }
        }
        m /= 2;
        K *= 2;
    }  
    int index[n];
    fftResort(n, index);
    for (int i = 0; i < n; i++)
    {
        z[i]= z[index[i]] / sqrt(n);
    }
    return z;
}

// FFT Aufruf
//[[Rcpp::export]]
Rcpp::List fastFourier(int r,std::vector<std::complex<double>> a){
    int n = pow(2,r);
    a = fft(a,r);
    std::vector<std::complex<double>> re(n);
    std::vector<std::complex<double>> im(n);
    for (int i = 0; i < n; i++)
    {
        re[i] = real(a[i]);
        im[i] = imag(a[i]);
    }
    return List::create(Named("real") = re, Named("imag") = im);
}
```

```{r}
ff1 = fastFourier(6, datenMatrix[,c(300:363)])
plot(1:2^6, ff1$real,"l")
```

```{r}
#ff2 = fastFourier(12, datenMatrix3[c(0:4095),166])
#plot(1:2^12, ff2$real,"l")

k <- 0:1023
fftest = fastFourier(10, sin(k))
plot(1:1024, fftest$real, "l")

```

# Fazit
Wir erhalten bei den meisten Werten ein nicht chaotisches Verhalten zwischen $\theta$ und $\dot \theta$, können jedoch auch chaotische Situationen konstruieren. Dies ist im physikalischen Sinne auch nachvollziehbar, da die Eigenrotation des Mondes durch geschickt gewählte Bahnen stark von der Radiusvariation beeinflusst werden kann.

Wir können aber sehen, dass dieses Verhalten nicht immer eintritt und wir im Allgemeinen ein strukturiertes Verhalten vorfinden.


\begin{thebibliography}{99}

\bibitem{kepler}
Keplersche Gesetze \url{https://de.wikipedia.org/wiki/Keplersche_Gesetze}, Stand 22.06.2021

\end{thebibliography}
